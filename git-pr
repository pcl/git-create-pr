#!/bin/bash
# -*- mode: python -*-

# From https://stackoverflow.com/questions/47882916/how-to-make-the-shebang-be-able-to-choose-the-correct-python-interpreter-between

# Shell commands follow
# Next line is bilingual: it starts a comment in Python, and is a no-op in shell
""":"

# First, check if we're running in a packaged context
executable="$(dirname $0)/$(ls -l "$0" | sed 's/.* -> //')"
dir="$(dirname "$executable")"
if [ -f "$dir/../libexec/pip-selfcheck.json" ]; then
    source "$dir/../libexec/bin/activate"
    exec python3 $0 "$@"
fi

# If that didn't work, find a suitable python interpreter. TODO: alternate locations for Windows and Linux

for cmd in python3 python /usr/local/Cellar/python/3.6.1/bin/python3 ; do
    command -V >/dev/null $cmd 2>&1 && ( $cmd -V 2>&1 | grep -c 3 >/dev/null ) && exec $cmd $0 "$@"
done

for dir in /usr/local/Cellar/python/; do 
    if [ -d "$dir" ]; then
        pydir="$(ls -r1 $dir | grep '^3' | head -n 1)"
        if [ -x "$dir/bin/python3" ]; then
            exec "$dir/bin/python3" $0 "$@"
        fi
    fi
done

echo "Couldn't find a Python 3 interpreter!" >&2

exit -2

":"""
# Previous line is bilingual: it ends a comment in Python, and is a no-op in shell
# Shell commands end here
# Python script follows

import argparse
import getpass
import json
import re
import requests
from subprocess import *
import sys
import tabulate

class PullRequestController:

    remotes = []
    interactive = True
    session = None

    def configure(self):
        (host, self.origin_org, self.origin_repo) = self.parse_remote('origin')

        result = run(['git', 'config', '--get', 'git-pr.%s.token' % host], stdout=PIPE)
        if result.returncode != 0:
            print('''A GitHub token must be provided. Generate one on GitHub:
    https://%s/settings/tokens/new

The token needs to have the 'repo' scope (or probably some subset of it).

Then, add it to your git config: 
    git-pr set-token <github-token>''' % host)
            return -1

        auth_token = str(result.stdout, 'utf-8').strip()

        self.session = requests.Session()
        self.session.headers.update({ "Authorization": "token %s" % auth_token })

        # GitHub Enterprise deployments host the API at <server>/api; GitHub itself
        # hosts the API at <api.github.com>
        if host == 'github.com':
            self.rest_api = 'https://api.github.com'
            self.graphql_api = 'https://api.github.com/graphql'
            self.web_url = 'https://github.com'
        else:
            self.rest_api = 'https://' + host + "/api/v3"
            self.graphql_api = 'https://' + host + '/api/graphql'
            self.web_url = 'https://' + host
        
        self.remotes = [r for r in str(check_output(['git', 'remote']), 'utf-8').split('\n') if r != '']
        if len(self.remotes) == 0:
            print("Coudn't find any remotes. Is this git repo configured yet?")
            return -1

        return 0

    def parse_remote(self, remote_name):
        url = sh('git', 'config', '--get', 'remote.%s.url' % remote_name)
        return self.parse_remote_ssh_url(url)

    def parse_remote_ssh_url(self, remote_ssh_url):
        matches = re.match(r"^git@(.*):(.*)/(.*).git$", remote_ssh_url)
        return (matches[1], matches[2], matches[3])

    def suggested_reviewers_query(self, pr_number):
        return '''query {
            repository(owner: "%s", name: "%s") {
                pullRequest(number: %d) {
                    suggestedReviewers { reviewer { name, login } }
                }
            }
        }''' % (self.origin_org, self.origin_repo, pr_number)

    def graphq(self, graphql_query):
        json_query = { "query": graphql_query }
        response = self.session.post(self.graphql_api, data=json.dumps(json_query))
        if 'errors' in response.json():
            raise Exception(response.content)
        else:
            return response.json()

    def pulls_url(self):
        return "%s/repos/%s/%s/pulls" % (self.rest_api, self.origin_org, self.origin_repo)

    def pull_url(self, pr_number):
        return "%s/%d" % (self.pulls_url(), pr_number)

    def create_pr(self, remote, branch, reviewer):
        if remote == None:
            (_, remote_user, _) = self.parse_remote(remote)
            remote_head = "%s:%s" % (remote_user, branch)
        else:
            if remote == 'origin': # TODO support for repositories whose origin remote is not named 'origin'
                remote_head = branch
            else:
                remote_head = "%s:%s" % (remote, branch)

        changes_vs_origin = sh('git', 'log', 'origin/master..@', '--format=format:%H').split('\n')
        if len(changes_vs_origin) == 0:
            print("Local branch contains no changes vs. origin/master!")
            return -1
        else:
            # If there are multiple changes, let's assume the oldest one is the most interesting.
            # TODO: ask the user which change to use if there are more than one.
            change = changes_vs_origin[-1]

        title = sh('git', 'show', '-q', change, '--format=format:%s')
        body = sh('git', 'show', '-q', change, '--format=format:%b')

        try:
            response = self.session.post(self.pulls_url(), data=json.dumps({ 
                "title": title, 
                "body": body,
                "head": remote_head, 
                "base": "master" 
            }))
        except Exception as ex:
            print("PR creation failed! Output: \n%s" % ex)
            return -1

        response_json = response.json()
        if 'number' not in response_json:
            print("PR creation failed! Output: %s; Errors: \n%s" %
                  (response_json['message'], response_json['errors']))
            return -1
        else:
            pr_number = response_json['number']

        if reviewer != None: # A reviewer was provided on the command line; use it.
            print("Created PR %d." % pr_number)
            return self.assign_pr(pr_number, reviewer)
        elif (not self.interactive): # Non-interactive and no command-line assignment; we're done.
            print("Created PR %d." % pr_number)
            return 0
        else: # interactive mode, and no reviewer. Ask for details.
            if self.ask("Created PR %d. Add a reviewer? [Y|n] " % pr_number):
                return self.assign_pr(pr_number, reviewer)
            else:
                return 0

    def do_assign(self, args):
        config_status = self.configure()
        if config_status != 0:
            return config_status
        else:
            return self.assign_pr(args.pr_number, args.reviewer)
    
    def assign_pr(self, pr_number, reviewer):
        if reviewer == None and not self.interactive:
            return 0
        
        if self.interactive and reviewer == None:
            suggested_reviewers_response_json = self.graphq(self.suggested_reviewers_query(pr_number))
            suggested_reviewers = suggested_reviewers_response_json['data']['repository']['pullRequest']['suggestedReviewers']
            suggested_logins = [ r['reviewer']['login'] for r in suggested_reviewers ]
            if suggested_logins != None and len(suggested_logins) > 0:
                suggestion_text=" (Suggestions: %s)" % " ".join(suggested_logins)
            else:
                suggestion_text=""

            reviewer = input("Enter reviewer id%s: " % suggestion_text)
            
        if reviewer != None:
            try:
                reviewers_response = self.session.post('%s/requested_reviewers' % self.pull_url(pr_number),
                                                       data='{ "reviewers": [ "%s" ] }' % reviewer)
                if reviewers_response.status_code >= 300:
                    print("Unexpected response from PR assignment call! %d. Response payload:\n%s" % (
                        reviewers_response.status_code, reviewers_response.content))
                    return -1
                else:
                    print("Assigned PR %d to %s" % (pr_number, reviewer))
                    return 0
            except Exception as ex:
                print("Failed to assign reviewer! Note that reviewers must be repo collaborators.")
                print(ex)
                return -1

        return 0
    
    def ask(self, msg):
        boolean_response = input(msg)
        return boolean_response == '' or boolean_response == 'y' or boolean_response == 'Y'

    def do_push(self, args):
        config_status = self.configure()
        if config_status != 0:
            return config_status

        if args.remote != None and args.branch != None:
            sh('git', 'push', args.remote, 'HEAD:refs/heads/%s' % args.branch)
            return self.create_pr(args.remote, args.branch, args.reviewer)
        elif args.branch == None:
            print('''When specifying a remote, you must also provide a remote branch name:

    git pr push <remote> <branch>''')
            return -1

        # A remote and branch wasn't specified. Look around to see if the current HEAD
        # has already been pushed somewhere.
        head_sha = sh('git', 'reflog', '-n', '1', '--format=format:%H')
        for remote in self.remotes:
            lines = sh('git', 'ls-remote', '--heads', remote).split('\n')
            candidate_shas = [l for l in lines if head_sha in l]
            if len(candidate_shas) > 0:
                candidate_branch = re.match(r".*\trefs/heads/(.*)$", candidate_shas[0])[1]
                # TODO instead of short-circuiting, perhaps look at all remotes and prompt if multiple?
                return self.create_pr(remote, candidate_branch, args.reviewer)

        print('''The local branch hasn't been pushed to a remote branch. Please push first, 
or provide remote and branch names: 

    git pr push <remote> <branch>''')
        return -1

    def pulls_query(self):
        # TODO first or last? Sort order? Paginate, or at least indicate incompleteness!
        return '''query {
            repository(owner: "%s", name: "%s") {
                pullRequests(last: 30, states: OPEN) {
                    nodes() { 
                        number,
                        title,
                        mergeable, 
                        viewerDidAuthor,
                        viewerSubscription,
                        author { login },
                        commits(last: 1) {
                            edges {
                                node {
                                    commit {
                                        status { state }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }''' % (self.origin_org, self.origin_repo)

    def do_list(self, args):
        # TODO indicate the PR for the current branch, if any
        config_status = self.configure()
        if config_status != 0:
            return config_status
        
        response = self.graphq(self.pulls_query())

        def status(node):
            # TODO include merge review requirements in this
            mergeable = node['mergeable'] == 'MERGEABLE'
            commit_status = node['commits']['edges'][0]['node']['commit']['status']
            if commit_status != None:
                check_results = commit_status['state'].lower()
                if check_results == "success":
                    if mergeable:
                        return status_from_mergeable_state(node, "? attention required")
                    else:
                        return "⨯ merge conflict"
                elif check_results == "pending":
                    if mergeable:
                        return status_from_mergeable_state(node, "? checks pending")
                    else:
                        return "⨯ merge conflict; checks pending"
                elif check_results == "failure":
                    return "⨯ checks failed"
                else:
                    return "⨯ unknown check result: " + check_results
            else:
                return "? commit status unavailable"

        def get_mergeable_state(pr_number):
            response = self.session.get(self.pull_url(pr_number))
            return response.json()['mergeable_state']
        
        def status_from_mergeable_state(node, dirty_text):
            mergeable_state = get_mergeable_state(node['number'])
            if mergeable_state == "blocked":
                return "  awaiting review"
            elif mergeable_state == "dirty":
                return dirty_text
            elif mergeable_state == "clean":
                return "✔ ready to merge"
            elif mergeable_state == 'unstable':
                return "⨯ unstable"
            else:
                return "⨯ unknown mergeable_state: " + mergeable_state

        def filter(node):
            if args.filter == 'open':
                return True
            else:
                return node['viewerDidAuthor'] or node['viewerSubscription'] == 'SUBSCRIBED'

        nodes = [ (n['number'], n['author']['login'], status(n), n['title'])
                  for n in response['data']['repository']['pullRequests']['nodes'] if filter(n) ]
        nodes.reverse()

        if len(nodes) > 0:
            print(tabulate.tabulate(nodes, headers=['PR', 'Author', 'Status', 'Title']))
            print()
            print("  To view a PR on the web:                         git pr browse <pr-no>")
            print("  To merge a PR in the 'ready to merge' state:     git pr merge <pr-no>")
            print("  To create a local tracking branch for a PR:      git pr checkout <pr-no>")
        else:
            print("You don't have any %s PRs! Time to write some code." % args.filter)
        return 0

    def open_url(self, url):
        # TODO open() for Linux, Windows.
        sh('open', url)
        
    def do_browse(self, args):
        config_status = self.configure()
        if config_status != 0:
            return config_status

        def open_subpath(subpath):
            self.open_url('%s/%s/%s/%s' % (self.web_url, self.origin_org, self.origin_repo, subpath))

        if args.pr_number != None and len(args.pr_number) > 0:
            for number in args.pr_number:
                pr = 'pull/%d' % number
                open_subpath(pr)
        else:
            open_subpath('pulls')
    
    def fetch_checkout_branch_spec(self, pr_number):
        response = self.session.get(self.pull_url(pr_number))
        pr = response.json()
        if 'head' not in pr: # the branch has been deleted
            return None
        else:
            (_, owner, _) = self.parse_remote_ssh_url(pr['head']['repo']['ssh_url'])
            return (owner, pr['head']['repo']['ssh_url'], pr['head']['ref'])

    def do_checkout(self, args):
        config_status = self.configure()
        if config_status != 0:
            return config_status

        pr_number = args.pr_number
        local_branch = 'pr-%d' % pr_number
        
        # strip the first two chars since we can't rely on 'git branch --format'
        branches = [x[2:] for x in sh('git', 'branch').split('\n')]
        if local_branch in branches:
            print("You already have a local branch called %s!" % local_branch)
            return -1
        
        (repo_name, repo_url, remote_branch) = self.fetch_checkout_branch_spec(pr_number)

        if repo_name not in self.remotes: # TODO check if it's 'origin' or under a different name
            sh('git', 'remote', 'add', repo_name, repo_url)
            self.remotes.append(repo_name)

        call(['git', 'fetch', repo_name])
        call(['git', 'checkout', '-b', local_branch, '%s/%s' % (repo_name, remote_branch) ])

    def do_merge(self, args):
        config_status = self.configure()
        if config_status != 0:
            return config_status
        pr_number = args.pr_number

        pull_url = self.pull_url(pr_number)
        merge_response = self.session.put('%s/merge' % pull_url)
        merge_result = merge_response.json()
        print(merge_result['message'])
        if merge_response.status_code > 299:
            if merge_response.status_code == 405:
                print("Ensure that your repository allows the 'merge' method for the merge button")
            print("")
            print("To view the PR: 'git pr browse %d'" % pr_number)
        else:
            if args.delete or self.interactive and self.ask("Delete PR branch? [Y|n]: "):
                pr_response = self.session.get(pull_url)
                pr = pr_response.json()
                if 'head' in pr: # perhaps the branch has already been deleted
                    branchname = pr['head']['ref']
                    repo_url = pr['head']['repo']['url']
                    self.session.delete("%s/git/refs/heads/%s" % (repo_url, branchname))
                    sh('git', 'fetch', 'origin')
                    sh('git', 'remote', 'prune', 'origin')
                    # TODO fetch and prune the user's fork, too
                else:
                    print("""Error: didn't find the expected data in the PR output! To delete this PR, open
the PR in your browser: 'git pr browse %d'""" % pr_number)

    def do_set_token(self, args):
        (host, _, _) = self.parse_remote('origin')
        if args.token == None:
            token = getpass.getpass("Enter token for %s: " % host)
            if token == None:
                print("Error: no token provided!")
                return -1
        else:
            token = args.token

        run(['git', 'config', '--unset-all', 'git-pr.%s.token' % host])
        sh('git', 'config', '--global', '--add', 'git-pr.%s.token' % host, token)

def sh(*args):
    return str(check_output(args), 'utf-8').strip()
        
def main(args):
    parser = argparse.ArgumentParser(description='Manage GitHub pull requests without leaving your $SHELL')

    subparsers = parser.add_subparsers()

    parser_help = subparsers.add_parser('help')
    parser_help.set_defaults(func=lambda prc, args: parser.print_help())

    parser_push = subparsers.add_parser('push', help='Push a PR. Push HEAD to the specified '
                                          + 'remote and branch, if provided. Otherwise, push to the tracking '
                                          + 'branch, if configured.')
    parser_push.set_defaults(func=lambda prc, args: prc.do_push(args))
    parser_push.add_argument('-r', '--reviewer', dest='reviewer', type=str, nargs='?', default=None)
    parser_push.add_argument('remote', type=str, nargs='?', help='The remote to push HEAD to. If specified,'
                               + " 'branch' must also be provided.")
    parser_push.add_argument('branch', type=str, nargs='?', help='The name of the branch to push to at '
                               + 'the specified remote.')
    
    parser_assign = subparsers.add_parser('assign', help='Assign a PR to a reviewer')
    parser_assign.set_defaults(func=lambda prc, args: prc.do_assign(args))
    parser_assign.add_argument('pr_number', metavar='pr-number', type=int)
    parser_assign.add_argument('reviewer', type=str, nargs="?")
    
    parser_list = subparsers.add_parser('list', help='List open PRs in the current origin repo')
    parser_list.set_defaults(func=lambda prc, args: prc.do_list(args))
    parser_list.add_argument("filter", type=str, choices=[ "open", "subscribed" ],
                             default="subscribed", nargs='?',
                             help='A filter to apply to the PRs to list. Defaults to all open PRs'
                             + ' that you are subscribed to or that you created.')

    parser_browse = subparsers.add_parser('browse', 
        help='Open the specified PR in your browser, or the PR list page, if none is specified.')
    parser_browse.set_defaults(func=lambda prc, args: prc.do_browse(args))
    parser_browse.add_argument('pr_number', metavar='pr-number', type=int, nargs='*', default=None)

    parser_checkout = subparsers.add_parser('checkout', help='Create a local tracking branch for a ' +
                                            'given PR, and check it out.')
    parser_checkout.set_defaults(func=lambda prc, args: prc.do_checkout(args))
    parser_checkout.add_argument('pr_number', metavar='pr-number', type=int)

    parser_merge = subparsers.add_parser('merge', help="Merge the specified PR, using a merge commit.")
    parser_merge.set_defaults(func=lambda prc, args: prc.do_merge(args))
    parser_merge.add_argument('pr_number', metavar='pr-number', type=int)
    parser_merge.add_argument('-d', '--delete-branch', dest='delete', action='store_true',
                              help="Delete the PR branch after successful merge")

    parser_set_token = subparsers.add_parser('set-token', help="Set the token for the current remote repository, optionally reading the token from stdin.")
    parser_set_token.set_defaults(func=lambda prc, args: prc.do_set_token(args))
    parser_set_token.add_argument('token', type=str, nargs='?', default=None)

    args = parser.parse_args()

    # TODO move all the error logging here, instead of doing inline error prints
    if 'func' in args:
        return args.func(PullRequestController(), args)
    else:
        parser.print_help()
        return -1

if __name__ == "__main__":
    tabulate.PRESERVE_WHITESPACE = True
    sys.exit(main(sys.argv))
