#!/bin/bash
# -*- mode: python -*-

# From https://stackoverflow.com/questions/47882916/how-to-make-the-shebang-be-able-to-choose-the-correct-python-interpreter-between

# Shell commands follow
# Next line is bilingual: it starts a comment in Python, and is a no-op in shell
""":"

# Find a suitable python interpreter. TODO: alternate locations for Windows and Linux

for cmd in python3 python /usr/local/Cellar/python/3.6.1/bin/python3 ; do
    command -V >/dev/null $cmd 2>&1 && ( $cmd -V 2>&1 | grep -c 3 >/dev/null ) && exec $cmd $0 "$@"
done

for dir in /usr/local/Cellar/python/; do 
    if [ -d "$dir" ]; then
        pydir="$(ls -r1 $dir | grep '^3' | head -n 1)"
        if [ -x "$dir/bin/python3" ]; then
            exec "$dir/bin/python3" $0 "$@"
        fi
    fi
done

echo "Couldn't find a Python 3 interpreter!" >&2

exit -2

":"""
# Previous line is bilingual: it ends a comment in Python, and is a no-op in shell
# Shell commands end here
# Python script follows (example commands shown)

import argparse
import json
import re
import requests
from subprocess import *
import sys
import tabulate

class PullRequestController:

    remotes = []
    interactive = True
    session = None

    def configure(self):
        try:
            auth_token = str(check_output(['git', 'config', '--get', 'prtools.token']), 'utf-8').strip()
        except OSError:
            print('''"A GitHub token must be provided. Generate one on GitHub:
    https://github.com/settings/tokens/new

The token needs to have the 'repo' scope (or probably some subset of it).

Then, add it to your git config: 
    git config --global --add prtools.token <github-token>''')
            return -1

        self.session = requests.Session()
        self.session.headers.update({ "Authorization": "token %s" % auth_token })

        (host, self.origin_org, self.origin_repo) = self.parse_remote('origin')

        # GitHub Enterprise deployments host the API at <server>/api; GitHub itself
        # hosts the API at <api.github.com>
        if host == 'github.com':
            self.rest_api = 'https://api.github.com'
            self.graphql_api = 'https://api.github.com/graphql'
            self.web_url = 'https://github.com'
        else:
            self.rest_api = 'https://' + host + "/api/v3"
            self.graphql_api = 'https://' + host + '/api/graphql'
            self.web_url = 'https://' + host
        
        self.remotes = [r for r in str(check_output(['git', 'remote']), 'utf-8').split('\n') if r != '']
        if len(self.remotes) == 0:
            print("Coudn't find any remotes. Is this git repo configured yet?")
            return -1
        elif len([r for r in self.remotes if r != 'origin']) == 0:
                print('''Couldn't find any remotes other than origin. Perhaps you
should create a fork? You can do this with the 'hub' CLI tool:
    hub fork''')

        return 0

    def parse_remote(self, remote_name):
        url = str(check_output(['git', 'config', '--get', 'remote.%s.url' % remote_name]), 'utf-8')
        return self.parse_remote_ssh_url(url)

    def parse_remote_ssh_url(self, remote_ssh_url):
        matches = re.match(r"^git@(.*):(.*)/(.*).git$", remote_ssh_url)
        return (matches[1], matches[2], matches[3])

    def suggested_reviewers_query(self, pr_number):
        return '''query {
            repository(owner: "%s", name: "%s") {
                pullRequest(number: %d) {
                    suggestedReviewers { reviewer { name, login } }
                }
            }
        }''' % (self.origin_org, self.origin_repo, pr_number)

    def graphq(self, graphql_query):
        json_query = { "query": graphql_query }
        response = self.session.post(self.graphql_api, data=json.dumps(json_query))
        response_json = json.loads(response.content)
        if 'errors' in response_json:
            raise Exception(response.content)
        else:
            return response_json

    def pull_url(self):
        return "%s/repos/%s/%s/pulls" % (self.rest_api, self.origin_org, self.origin_repo)

    def create_pr(self, remote, branch, reviewer):
        (_, remote_user, _) = self.parse_remote(remote)
        remote_head = "%s:%s" % (remote_user, branch)

        title = str(check_output(['git', 'log', '-n', '1', '--format=format:%s']), 'utf-8').strip()
        title = re.sub(r'"', '', title)

        try:
            response = self.session.post(self.pull_url(), data='''{ 
                "title": "%s", 
                "head": "%s", 
                "base": "master" 
            }''' % (title, remote_head))
        except Exception as ex:
            print("PR creation failed! Output: \n%s" % ex)
            return -1

        response_json = json.loads(response.content)
        if 'number' not in response_json:
            print("PR creation failed! Output: \n%s" % response)
            return -1
        else:
            pr_number = response_json['number']

        status = 0
        if (not self.interactive) or self.ask("PR %d created! Add a reviewer? [Y|n] " % pr_number):
            status = self.assign_pr(pr_number, reviewer)

        if self.interactive and self.ask("Open in a browser? [Y|n] "):
            self.open_url(response_json['html_url'])

        return status

    def do_assign(self, args):
        config_status = self.configure()
        if config_status != 0:
            return config_status
        else:
            return self.assign_pr(args.pr_number, args.reviewer)
    
    def assign_pr(self, pr_number, reviewer):
        if reviewer == None and not self.interactive:
            return 0
        
        if self.interactive and reviewer == None:
            suggested_reviewers_response_json = self.graphq(self.suggested_reviewers_query(pr_number))
            suggested_reviewers = suggested_reviewers_response_json['data']['repository']['pullRequest']['suggestedReviewers']
            suggested_logins = [ r['reviewer']['login'] for r in suggested_reviewers ]
            if suggested_logins != None and len(suggested_logins) > 0:
                suggestion_text=" (Suggestions: %s)" % " ".join(suggested_logins)
            else:
                suggestion_text=""

            reviewer = input("Enter reviewer id%s: " % suggestion_text)
            
        if reviewer != None:
            try:
                reviewers_response = self.session.post('%s/%d/requested_reviewers' % (self.pull_url(), pr_number),
                                                       data='{ "reviewers": [ "%s" ] }' % reviewer)
                if reviewers_response.status_code >= 300:
                    print("Unexpected response from PR assignment call! %d. Response payload:\n%s" % (
                        reviewers_response.status_code, reviewers_response.content))
                    return -1
                else:
                    print("Assigned PR %d to %s" % (pr_number, reviewer))
                    return 0
            except Exception as ex:
                print("Failed to assign reviewer! Note that reviewers must be repo collaborators.")
                print(ex)
                return -1

        return 0
    
    def ask(self, msg):
        boolean_response = input(msg)
        return boolean_response == '' or boolean_response == 'y' or boolean_response == 'Y'

    def do_create(self):
        config_status = self.configure()
        if config_status != 0:
            return config_status
        
        head_sha = str(check_output(['git', 'reflog', '-n', '1', '--format=format:%H']), 'utf-8').strip()
        for remote in self.remotes:
            if remote == 'origin' or remote == '':
                continue
            
            lines = str(check_output(['git', 'ls-remote', '--heads', remote]), 'utf-8').split('\n')
            candidate_shas = [l for l in lines if head_sha in l]
            if len(candidate_shas) > 0:
                candidate_branch = re.match(r".*\trefs/heads/(.*)$", candidate_shas[0])[1]
                # TODO instead of short-circuiting, perhaps look at all remotes and prompt if multiple?
                return self.create_pr(remote, candidate_branch, None)

        print("No changes found in the local repo!")
        return -1

    def pulls_query(self):
        # TODO first or last? Sort order? Paginate, or at least indicate incompleteness!
        return '''query {
            repository(owner: "%s", name: "%s") {
                pullRequests(last: 30, states: OPEN) {
                    nodes() { 
                        number,
                        title,
                        mergeable, 
                        viewerDidAuthor,
                        viewerSubscription,
                        author { login },
                        commits(last: 1) {
                            edges {
                                node {
                                    commit {
                                        status { state }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }''' % (self.origin_org, self.origin_repo)

    def do_list(self, args):
        # TODO indicate the PR for the current branch, if any
        config_status = self.configure()
        if config_status != 0:
            return config_status
        
        response = self.graphq(self.pulls_query())

        def status(node):
            # TODO include merge review requirements in this
            mergeable = node['mergeable'] == 'MERGEABLE'
            check_results = node['commits']['edges'][0]['node']['commit']['status']['state'].lower()
            if check_results == "success":
                if mergeable:
                    return status_from_mergeable_state(node, "? attention required")
                else:
                    return "⨯ merge conflict"
            elif check_results == "pending":
                if mergeable:
                    return status_from_mergeable_state(node, "? checks pending")
                else:
                    return "⨯ merge conflict; checks pending"
            elif check_results == "failure":
                return "⨯ checks failed"
            else:
                return "⨯ unknown check result: " + check_results

        def get_mergeable_state(pr_number):
            response = self.session.get('%s/%d' % (self.pull_url(), pr_number))
            return json.loads(response.content)['mergeable_state']
        
        def status_from_mergeable_state(node, dirty_text):
            mergeable_state = get_mergeable_state(node['number'])
            if mergeable_state == "blocked":
                return "  awaiting review"
            elif mergeable_state == "dirty":
                return dirty_text
            elif mergeable_state == "clean":
                return "✔ ready to merge"
            elif mergeable_state == 'unstable':
                return "⨯ unstable"
            else:
                return "⨯ unknown mergeable_state: " + mergeable_state

        def filter(node):
            if args.filter == 'open':
                return True
            else:
                return node['viewerDidAuthor'] or node['viewerSubscription'] == 'SUBSCRIBED'

        nodes = [ (n['number'], n['author']['login'], status(n), n['title'])
                  for n in response['data']['repository']['pullRequests']['nodes'] if filter(n) ]
        nodes.reverse()

        if len(nodes) > 0:
            print(tabulate.tabulate(nodes, headers=['PR', 'Author', 'Status', 'Title']))
            print()
            print("  To view a PR on the web:                         git pr browse <pr-no>")
            print("  To merge a PR in the 'ready to merge' state:     git pr merge <pr-no>")
            print("  To create a local tracking branch for a PR:      git pr checkout <pr-no>")
        else:
            print("You don't have any %s PRs! Time to write some code." % args.filter)
        return 0

    def open_url(self, url):
        # TODO open() for Linux, Windows.
        check_output(['open', url])
        
    def do_browse(self, args):
        config_status = self.configure()
        if config_status != 0:
            return config_status

        def open_subpath(subpath):
            self.open_url('%s/%s/%s/%s' % (self.web_url, self.origin_org, self.origin_repo, subpath))

        if args.pr_number != None and len(args.pr_number) > 0:
            for number in args.pr_number:
                pr = 'pull/%d' % number
                open_subpath(pr)
        else:
            open_subpath('pulls')
    
    def fetch_checkout_branch_spec(self, pr_number):
        response = self.session.get('%s/%d' % (self.pull_url(), pr_number))
        pr = json.loads(response.content)
        if 'head' not in pr: # the branch has been deleted
            return None
        else:
            (_, owner, _) = self.parse_remote_ssh_url(pr['head']['repo']['ssh_url'])
            return (owner, pr['head']['repo']['ssh_url'], pr['head']['ref'])

    def do_checkout(self, args):
        config_status = self.configure()
        if config_status != 0:
            return config_status

        pr_number = args.pr_number
        local_branch = 'pr-%d' % pr_number
        
        branches = str(check_output(['git', 'branch', '--format=%(refname:short)']), 'utf-8').split('\n')
        if local_branch in branches:
            print("You already have a local branch called %s!" % local_branch)
            return -1
        
        (repo_name, repo_url, remote_branch) = self.fetch_checkout_branch_spec(pr_number)

        if repo_name not in self.remotes: # TODO check if it's 'origin' or under a different name
            check_output(['git', 'remote', 'add', repo_name, repo_url])
            self.remotes.append(repo_name)

        call(['git', 'fetch', repo_name])
        call(['git', 'checkout', '-b', local_branch, '%s/%s' % (repo_name, remote_branch) ])

    def do_merge(self, args):
        config_status = self.configure()
        if config_status != 0:
            return config_status

        print("Not yet implemented!")

def main(args):
    parser = argparse.ArgumentParser(description='Manage GitHub pull requests without leaving your $SHELL')
    subparsers = parser.add_subparsers()

    parser_help = subparsers.add_parser('help')
    parser_help.set_defaults(func=lambda args: parser.print_help())

    parser_create = subparsers.add_parser('create', help='Create a new PR for the current branch')
    parser_create.set_defaults(func=lambda args: PullRequestController().do_create())
    
    parser_assign = subparsers.add_parser('assign', help='Assign a PR to a reviewer')
    parser_assign.set_defaults(func=lambda args: PullRequestController().do_assign(args))
    parser_assign.add_argument('pr_number', metavar='pr-number', type=int)
    parser_assign.add_argument('reviewer', type=str, nargs="?")
    
    parser_list = subparsers.add_parser('list', help='List open PRs in the current origin repo')
    parser_list.set_defaults(func=lambda args: PullRequestController().do_list(args))
    parser_list.add_argument("filter", type=str, choices=[ "open", "subscribed" ],
                             default="subscribed", nargs='?',
                             help='A filter to apply to the PRs to list. Defaults to all open PRs'
                             + ' that you are subscribed to or that you created.')

    parser_browse = subparsers.add_parser('browse', 
        help='Open the specified PR in your browser, or the PR list page, if none is specified.')
    parser_browse.set_defaults(func=lambda args: PullRequestController().do_browse(args))
    parser_browse.add_argument('pr_number', metavar='pr-number', type=int, nargs='*', default=None)

    parser_checkout = subparsers.add_parser('checkout', help='Create a local tracking branch for a ' +
                                            'given PR, and check it out.')
    parser_checkout.set_defaults(func=lambda args: PullRequestController().do_checkout(args))
    parser_checkout.add_argument('pr_number', metavar='pr-number', type=int)

    parser_merge = subparsers.add_parser('merge', help="Merge the specified PR using GitHub's APIs.")
    parser_merge.set_defaults(func=lambda args: PullRequestController().do_merge(args))
    parser_merge.add_argument('pr_number', metavar='pr-number', type=int)

    args = parser.parse_args()

    # TODO move all the error logging here, instead of doing inline error prints
    if 'func' in args:
        return args.func(args)
    else:
        parser.print_help()
        return -1

if __name__ == "__main__":
    tabulate.PRESERVE_WHITESPACE = True
    sys.exit(main(sys.argv))
