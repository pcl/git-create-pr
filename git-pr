#!/bin/bash

# From https://stackoverflow.com/questions/47882916/how-to-make-the-shebang-be-able-to-choose-the-correct-python-interpreter-between

# Shell commands follow
# Next line is bilingual: it starts a comment in Python, and is a no-op in shell
""":"

# Find a suitable python interpreter. TODO: alternate locations for Windows and Linux

for cmd in python3 python /usr/local/Cellar/python/3.6.1/bin/python3 ; do
    command -V >/dev/null $cmd 2>&1 && ( $cmd -V 2>&1 | grep -c 3 >/dev/null ) && exec $cmd $0 "$@"
done

for dir in /usr/local/Cellar/python/; do 
    if [ -d "$dir" ]; then
        pydir="$(ls -r1 $dir | grep '^3' | head -n 1)"
        if [ -x "$dir/bin/python3" ]; then
            exec "$dir/bin/python3" $0 "$@"
        fi
    fi
done

echo "Couldn't find a Python 3 interpreter!" >&2

exit -2

":"""
# Previous line is bilingual: it ends a comment in Python, and is a no-op in shell
# Shell commands end here
# Python script follows (example commands shown)

import json
import re
import requests
from subprocess import *
import sys

class PullRequestController:

    remotes = []
    interactive = True
    session = None

    def configure(self):
        try:
            auth_token = str(check_output(['git', 'config', '--get', 'prtools.token']), 'utf-8').strip()
        except OSError:
            print('''"A GitHub token must be provided. Generate one on GitHub:
    https://github.com/settings/tokens/new

The token needs to have the 'repo' scope (or probably some subset of it).

Then, add it to your git config: 
    git config --global --add prtools.token <github-token>''')
            return -1

        self.session = requests.Session()
        self.session.headers.update({ "Authorization": "token %s" % auth_token })

        (self.origin_api_path, self.origin_org, self.origin_repo) = self.parse_remote_url('origin')

        
        return 0
    
    def configure_for_pushing(self):
        self.remotes = str(check_output(['git', 'remote']), 'utf-8').split('\n')
        if len(self.remotes) == 0:
            print("Coudn't find any remotes. Is this git repo configured yet?")
            return -1
        else:
            self.remotes = [r for r in self.remotes if r != 'origin']
            if len(self.remotes) == 0:
                print('''Couldn't find any remotes other than origin. Perhaps you
should create a fork? You can do this with the 'hub' CLI tool:
    hub fork''')
                return -1

        return 0

    def parse_remote_url(self, remote):
        url = str(check_output(['git', 'config', '--get', 'remote.%s.url' % remote]), 'utf-8')
        matches = re.match(r"^git@(.*):(.*)/(.*).git$", url)
        return (matches[1], matches[2], matches[3])

    def suggested_reviewers_query(self, pr_number):
        return '''query {
            repository(owner: "%s", name: "%s") {
                pullRequest(number: %d) {
                    suggestedReviewers { reviewer { name, login } }
                }
            }
        }''' % (self.origin_org, self.origin_repo, pr_number)

    def graphq(self, graphql_query):
        json_query = { "query": graphql_query }
        graphql_url = 'https://%s/api/graphql' % self.origin_api_path
        response = self.session.post(graphql_url, data=json.dumps(json_query))
        response_json = json.loads(response.content)
        if 'errors' in response_json:
            raise Exception(response.content)
        else:
            return response_json

    def pull_url(self):
        return "https://%s/api/v3/repos/%s/%s/pulls" % (
            self.origin_api_path, self.origin_org, self.origin_repo)

    def create_pr(self, remote, branch, reviewer):
        (remote_api_path, remote_user, _) = self.parse_remote_url(remote)
        remote_head = "%s:%s" % (remote_user, branch)

        api_url = self.pull_url()

        title = str(check_output(['git', 'log', '-n', '1', '--format=format:%s']), 'utf-8').strip()
        title = re.sub(r'"', '', title)

        try:
            response = self.session.post(api_url, data='''{ 
                "title": "%s", 
                "head": "%s", 
                "base": "master" 
            }''' % (title, remote_head))
        except Exception as ex:
            print("PR creation failed! Output: \n%s" % ex)
            return -1

        response_json = json.loads(response.content)
        if 'number' not in response_json:
            print("PR creation failed! Output: \n%s" % response)
            return -1
        else:
            pr_number = response_json['number']

        response_json = self.graphq(self.suggested_reviewers_query(pr_number))
        suggested_reviewers = response_json['data']['repository']['pullRequest']['suggestedReviewers']
        suggested_logins = [ r['reviewer']['login'] for r in suggested_reviewers ]
        if suggested_logins != None and len(suggested_logins) > 0:
            suggestion_text=" (Suggestions: %s)" % " ".join(suggested_logins)
        else:
            suggestion_text=""

        status = 0
        if (reviewer != None or
            (self.interactive and
             self.ask("PR %d created! Add a reviewer?%s [Y|n] " % (pr_number, suggestion_text)))):

            if self.interactive and reviewer == None:
                reviewer = input("Enter reviewer id: ")
            if reviewer != None:
                reviewer_json = '{ "reviewers": [ "%s" ] }' % reviewer
                try:
                    response = self.session.post('%s/%d/requested_reviewers' % (api_url, pr_number),
                                                 data=json.dumps(reviewer_json))
                except Exception as ex:
                    print("Failed to assign reviewer! Note that reviewers must be repo collaborators.")
                    print(ex)
                    status = -1

        if self.interactive and self.ask("Open in a browser? [Y|n] "):
            # TODO open() for Linux, Windows.
            check_output(['open', json.loads(response.content)['html_url']])

        return status

    def ask(self, msg):
        boolean_response = input(msg)
        return boolean_response == None or boolean_response == 'y' or boolean_response == 'Y'

    def do_create(self):
        status = controller.configure_for_pushing()
        if status != 0:
            return status
        
        head_sha = str(check_output(['git', 'reflog', '-n', '1', '--format=format:%H']), 'utf-8').strip()
        for remote in self.remotes:
            if remote == 'origin' or remote == '':
                continue
            
            lines = str(check_output(['git', 'ls-remote', '--heads', remote]), 'utf-8').split('\n')
            candidate_shas = [l for l in lines if l.indexof(head_sha) != -1]
            if len(candidate_shas) > 0:
                candidate_rhs = candidate_shas[0].split(' ')
                candidate_branch = re.sub(r'refs/heads/', '', candidate_rhs)
                # TODO instead of short-circuiting, perhaps look at all remotes and prompt if multiple?
                return self.create_pr(remote, candidate_branch, None)

        print("No changes found in the local repo!")
        return -1

def main(args):
    if len(args) != 2 or args[1] != "create":
        print("Usage: git pr create")
        return -1
    else:
        controller = PullRequestController()

        # TODO move all the error logging here, instead of doing inline error prints
        status = controller.configure()
        if status != 0:
            return -1
        else:
            return controller.do_create()

if __name__ == "__main__":
    sys.exit(main(sys.argv))
